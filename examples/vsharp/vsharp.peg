%prefix "vsharp"

%auxil "vsparser_t *"

%header {

#include "vsparser.h"

}

%source {

#include <stdio.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef vsharp_context_t pcc_context_t;

int vsp_getchar(vsparser_t* p);
void vsp_debug(vsparser_t *p, int event, const char *rule, int level, size_t pos, const char *buffer, int length);
void vsp_error(vsparser_t *p);
void vsp_whitespace(pcc_context_t *ctx, struct pcc_thunk_chunk_tag *chunk);
void vsp_ast_info(struct pcc_thunk_chunk_tag* chunk, const char *name, int term, size_t start, size_t end);
void vsp_ast_gen(vsparser_t *p, const struct pcc_thunk_array_tag *thunks);

#ifdef __cplusplus
}
#endif

#define PCC_GETCHAR(auxil)\
        vsp_getchar(auxil)

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length)\
        vsp_debug(auxil, event, rule, (int)level, pos, buffer, (int)length)

#define PCC_ERROR(auxil)\
        vsp_error(auxil)

#define PCC_WHITESPACE(CTX, CHUNK)\
        if (CTX->term_mode == 0) vsp_whitespace(CTX, CHUNK)

#define PCC_AST_INFO(CHUNK, NAME, TERM, START, END)\
        vsp_ast_info(CHUNK, NAME, TERM, START, END)

#define PCC_ACTION(CTX, THUNKS, VALUE)\
        vsp_ast_gen(CTX->auxil, THUNKS)

}

compilation_unit
    : top_level_declaration* EOF _
    ;

fragment top_level_declaration
    : module_clause
    | import_directive
    | type_declaration
    | struct_declaration
    | field_declaration
    | function_declaration
    ;

module_clause
    : attributes? KW_MODULE module_identifier
    ;

module_identifier
    : IDENTIFIER
    ;

attributes
    : attribute_section+
    ;

fragment attribute_section
    : '[' attribute_list ']'
    ;

fragment attribute_list
    : attribute ( ',' attribute )*
    ;

attribute
    : KW_IF IDENTIFIER '?'?
    | ( KW_UNSAFE )
    | name=IDENTIFIER ( ':' ( string_literal | IDENTIFIER ) )?
    | interpreted_string_literal
    ;

interpreted_string_literal
    : string_literal
    ;

import_directive
    : KW_IMPORT module_name ( KW_AS alias_name=IDENTIFIER | '{' symbol_names=import_symbols '}' )?
    ;

module_name
    : IDENTIFIER ( '.' IDENTIFIER )*
    ;

import_symbols
    : IDENTIFIER ( ',' IDENTIFIER )*
    ;

type_declaration
    : attributes? KW_PUBLIC? KW_TYPE type_identifier generic_names? '=' sum_type_list
    ;

sum_type_list
    : type ( '|' type )*
    ;

struct_declaration
    : attributes? KW_PUBLIC? ( KW_STRUCT | KW_UNION | KW_CLASS | KW_INTERFACE | KW_ENUM )
        IDENTIFIER generic_names? ( ':' super_type_list )? '{' struct_member_list? '}'
    ;

generic_names
    : '<' generic_name_list '>'
    ;

generic_name_list
    : generic_name ( ',' generic_name )*
    ;

generic_name
    : IDENTIFIER
    ;

type
    : simple_type '&'? '?'?
    ;

super_type_list
    : super_type ( ',' super_type )*
    ;

super_type
    : generic_type
    | qualified_type
    | type_identifier
    ;

generic_type
    : ( qualified_type | type_identifier ) '<' type_list '>'
    ;

qualified_type
    : type_identifier '.' type_identifier
    ;

type_identifier
    : IDENTIFIER
    ;

simple_type
    : pointer_type
    | function_type
    | tuple_type
    | generic_type
    | qualified_type
    | type_identifier
    ;

pointer_type
    : simple_type '*'
    ;

function_type
    : KW_FUNCTION function_type_signature
    ;

function_type_signature
    : '(' type_list? ')' ( ':' type )?
    ;

tuple_type
    : '(' type_list ')'
    ;

type_list
    : type ( ',' type )*
    ;

struct_member_list
    : struct_member_declaration+
    ;

struct_member_declaration
    : field_declaration
    | function_declaration
    ;

field_declaration
    : attributes? KW_PUBLIC? ( KW_CONST | KW_LET | KW_VAR ) ( field_specifier_list | field_specifier )
    | attributes? KW_PUBLIC? field_specifier
    ;

field_specifier_list
    : '{' field_specifier* '}'
    ;

field_specifier
    : field_identifier ':' type ( '=' expression )?
    ;

field_identifier
    : IDENTIFIER
    ;

function_declaration
    : attributes? KW_PUBLIC? KW_CONST? 
        ( KW_FUNCTION? IDENTIFIER generic_names? function_signature ) block?
    ;

function_signature
    : '(' parameter_list? ')' ( ':' type )?
    ;

parameter_list
    : parameter_declaration ( ',' parameter_declaration )*
    ;

parameter_declaration
    : KW_CONST? IDENTIFIER ':' parameter_type
    ;

parameter_type
    : type '...'?
    ;

# -------------------- Statements ------------------------------

block
    : '{' statement_list? '}'
    ;

statement_list
    : statement+
    ;

statement
    : expression_statement
    ;

expression_statement
    : expression
    ;

# -------------------- Expressions ------------------------------

expression
    : IDENTIFIER
    | string_literal
    | integer_literal
    | boolean_literal
    | KW_NULL
    | KW_THIS
    | KW_BASE
    ;

string_literal
    : STRING_LITERAL
    ;

integer_literal
    : INTEGER_LITERAL
    ;

boolean_literal
    : KW_TRUE
    | KW_FALSE
    ;

keywords
    : KW_MODULE | KW_IMPORT | KW_AS
    ;

# -------------------- Terminals ------------------------------

IDENTIFIER
    : BASIC_IDENTIFIER
    | '@' keywords
    ;

BASIC_IDENTIFIER
    : LETTER LD*
    ;

KW_MODULE       : 'module'          ~LD
KW_IMPORT       : 'import'          ~LD
KW_AS           : 'as'              ~LD
KW_IF           : 'if'              ~LD
KW_UNSAFE       : 'unsafe'          ~LD
KW_PUBLIC       : 'public'          ~LD
KW_STRUCT       : 'struct'          ~LD
KW_UNION        : 'union'           ~LD
KW_CLASS        : 'class'           ~LD
KW_INTERFACE    : 'interface'       ~LD
KW_ENUM         : 'enum'            ~LD
KW_FUNCTION     : 'function'        ~LD
KW_TYPE         : 'type'            ~LD
KW_CONST        : 'const'           ~LD
KW_LET          : 'let'             ~LD
KW_VAR          : 'var'             ~LD
KW_TRUE         : 'true'            ~LD
KW_FALSE        : 'false'           ~LD
KW_NULL         : 'null'            ~LD
KW_THIS         : 'this'            ~LD
KW_BASE         : 'base'            ~LD

LETTER          : [a-zA-Zα-ωΑ-Ωµ_]
DIGIT           : [0-9]
LD              : LETTER | DIGIT

STRING_LITERAL  : '\"' ( ~'\"' . )* '\"'
INTEGER_LITERAL : [0-9]+

_               : (SPACE | EOL | COMMENT)*
SPACE           : [ \u0009\u000B\u000C]
COMMENT         : '//' ( ~EOL . )*
                | '/*' ( ~'*/' . )* '*/'
EOL             : '\n' | '\r\n' | '\r'
EOF             : ~.

%%

#include <stdarg.h>

void vsp_ast_info(struct pcc_thunk_chunk_tag* chunk, const char *name, int term, size_t start, size_t end) {
    if (chunk->thunks.len == 0) {
        return;
    }
    pcc_thunk_t* thunk = chunk->thunks.buf[chunk->thunks.len-1];
    if (chunk->ast_info.last_thunk == thunk) {
        return;
    }
    chunk->ast_info.last_thunk = thunk;

    thunk->ast_info.name = name;
    thunk->ast_info.term = term;
    thunk->ast_info.start = start;
    thunk->ast_info.end = end;
}

void vsp_ast_push(vsparser_t *p, const char* name, int term, size_t start, size_t end);
void vsp_ast_pop(vsparser_t *p, const char* name, bool succeeded);

void vsp_ast_dump(vsparser_t *p, const pcc_thunk_t* thunk) {
    const char *name = thunk->ast_info.name;
    if (!name) {
        return;
    }
    if (thunk->type == PCC_THUNK_NODE) {
        vsp_ast_push(p, name, thunk->ast_info.term, thunk->ast_info.start, thunk->ast_info.end);
        for (size_t i = 0; i < thunk->data.node.thunks->len; i++) {
            vsp_ast_dump(p, thunk->data.node.thunks->buf[i]);
        }
        vsp_ast_pop(p, name, true);
    }
}

void vsp_ast_gen(vsparser_t *p, const pcc_thunk_array_t *thunks) {
    if (thunks->len == 1) {
        thunks->buf[0]->ast_info.name = "root";
        vsp_ast_dump(p, thunks->buf[0]);
    }
}

void vsp_whitespace(pcc_context_t *ctx, pcc_thunk_chunk_t *chunk) {
    if (pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) {
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, chunk->thunks.len-1);
    }
}
