%prefix "vsharp"

%value "vsp_pos_t"
%auxil "vsparser_t *"

%header {

#include "vsparser.h"

}

%source {

#include <stdio.h>
#include <stdlib.h>

int vsp_getchar(vsparser_t* p);
void vsp_debug(vsparser_t *p, int event, const char *rule, int level, size_t pos, const char *buffer, int length);
void vsp_error(vsparser_t *p);

#define PCC_GETCHAR(auxil)\
        vsp_getchar(auxil)

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length)\
        vsp_debug(auxil, event, rule, (int)level, pos, buffer, (int)length)

#define PCC_ERROR(auxil)\
        vsp_error(auxil)

#define PCC_INVOKE(callback, ...)\
    if (auxil->il.callback)\
        auxil->il.callback(auxil, ##__VA_ARGS__)

#define VPOS(num)\
    vsp_pos(auxil, _##num##s, _##num##e)

#define VRANGE(start, end)\
    vsp_pos(auxil, _##start##s, _##end##e)

#define NPOS()\
    vsp_pos(auxil, 0, 0)

#define EMPTY(num)\
    (_##num##e <= _##num##s)

#ifndef TRUE
#define TRUE    1
#define FALSE   0
#endif

}

compilation_unit
    : _ (top_level_declaration _)* EOF
    ;

top_level_declaration
    : module_clause
    | import_declaration
    | type_declaration
    | struct_declaration
    | field_declaration
    | function_declaration
    ;

module_clause
    : ( attribute_list _ )?
        <KW_MODULE> _ <module_identifier>               { PCC_INVOKE(on_module_clause, VPOS(1), VPOS(2)); }
    ;

module_identifier
    : identifier
    ;

attribute_list
    : attribute_list _ attribute_declaration
    | attribute_declaration
    ;

attribute_declaration
    : '[' _ attribute_spec_list _ ']'
    ;

attribute_spec_list
    : attribute_spec_list _ ',' _ attribute_spec
    | attribute_spec
    ;

attribute_spec
    : KW_IF _ identifier ( _ '?' )?
    | ( KW_UNSAFE | identifier ) ( _ ':' _ ( string_literal | identifier ) )?
    | interpreted_string_literal
    ;

interpreted_string_literal
    : string_literal
    ;

import_declaration
    : <KW_IMPORT> _ <module_name>                       { PCC_INVOKE(enter_import_declaration, VPOS(1), VPOS(2)); }
      ( _ ( <KW_AS> _ <identifier>                      { PCC_INVOKE(on_import_alias, VPOS(3), VPOS(4)); }
      | '{' _ import_symbol_list _ '}' ) )?             { PCC_INVOKE(exit_import_declaration); }
    ;

module_name
    : module_name _ '.' _ <identifier>                  { PCC_INVOKE(on_import_module_name, VPOS(1), TRUE); }
    | identifier                                        { PCC_INVOKE(on_import_module_name, VPOS(0), FALSE); }
    ;

import_symbol_list
    : import_symbol_list _ ',' _ <identifier>           { PCC_INVOKE(on_import_symbol, VPOS(1)); }
    | identifier                                        { PCC_INVOKE(on_import_symbol, VPOS(0)); }
    ;

type_declaration
    : ( attribute_list _ )? ( KW_PUBLIC _ )?
        <KW_TYPE> _ <type_identifier>                   { PCC_INVOKE(enter_type_declaration, VPOS(1), VPOS(2)); }
        ( _ <generic_names> )?                          { if (!EMPTY(3)) { PCC_INVOKE(on_type_decl_generic_names, VPOS(3)); } }
        _ '=' _ <sum_type_list>                         { PCC_INVOKE(exit_type_declaration, VPOS(4)); }
    ;

sum_type_list
    : sum_type_list _ '|' _ type
    | type
    ;

struct_declaration
    : ( attribute_list _ )? ( KW_PUBLIC _ )?
        < KW_STRUCT | KW_UNION | KW_CLASS | KW_INTERFACE | KW_ENUM >
        _ <identifier>                                  { PCC_INVOKE(enter_struct_declaration, VPOS(1), VPOS(2)); }
        ( _ <generic_names> )?                          { if (!EMPTY(3)) { PCC_INVOKE(on_struct_generic_names, VPOS(3)); } }
        ( _ ':' _ super_type_list )?
        _ '{' _ ( struct_member_list _ )? '}'           { PCC_INVOKE(exit_struct_declaration, VPOS(0)); }
    ;

generic_names
    : '<' _ generic_name_list _ '>'                     { $$=VPOS(0); }
    ;

generic_name_list
    : generic_name_list _ ',' _ <generic_name>          { PCC_INVOKE(on_generic_name, VPOS(1)); }
    | generic_name                                      { PCC_INVOKE(on_generic_name, VPOS(0)); }
    ;

generic_name
    : identifier
    ;

type
    : simple_type ( _ <'&'> )? ( _ <'?'> )?             { $$=VPOS(0);
                                                          PCC_INVOKE(on_type_reference, VPOS(0), VPOS(1));
                                                          PCC_INVOKE(on_type_nullable, VPOS(0), VPOS(2)); }
    ;

super_type_list
    : super_type_list _ ',' _ super_type                { PCC_INVOKE(on_struct_super_type, TRUE); }
    | super_type                                        { PCC_INVOKE(on_struct_super_type, FALSE); }
    ;

super_type
    : generic_type
    | qualified_type
    | type_identifier
    ;

generic_type
    : ( qualified_type | type_identifier )              { PCC_INVOKE(enter_generic_type); }
        _ '<' _ type_list _ '>'                         { PCC_INVOKE(exit_generic_type); }
    ;

qualified_type
    : <type_identifier> _ '.' _ <type_identifier>       { PCC_INVOKE(on_named_type, VPOS(1), VPOS(2)); }
    ;

type_identifier
    : identifier                                        { PCC_INVOKE(on_named_type, NPOS(), VPOS(0)); }
    ;

simple_type
    : pointer_type
    | function_type
    | tuple_type
    | generic_type
    | qualified_type
    | type_identifier
    ;

pointer_type
    : simple_type _ <'*'>                               { PCC_INVOKE(on_type_pointer, VPOS(0), VPOS(1)); }
    ;

function_type
    : KW_FUNCTION                                       { PCC_INVOKE(enter_function_type); }
        _ function_type_signature                       { PCC_INVOKE(exit_function_type, VPOS(0)); }
    ;

function_type_signature
    : '(' _ ( type_list _ )? ')'                        { PCC_INVOKE(on_function_type_parameters); }
        ( _ ':' _ type )?                               { PCC_INVOKE(on_function_type_return_type, type); }
    ;

tuple_type
    :                                                   { PCC_INVOKE(enter_tuple_type); }
        '(' _ type_list _ ')'                           { PCC_INVOKE(exit_tuple_type, VPOS(0)); }
    ;

type_list
    : type_list _ ',' _ type                            { PCC_INVOKE(on_type_list_item, TRUE); }
    | type                                              { PCC_INVOKE(on_type_list_item, FALSE); }
    ;

struct_member_list
    : struct_member_list _ struct_member_declaration
    | struct_member_declaration
    ;

struct_member_declaration
    : field_declaration
    | function_declaration
    ;

field_declaration
    : ( attribute_list _ )? ( KW_PUBLIC _ )?
        < KW_CONST | KW_LET | KW_VAR > _                { PCC_INVOKE(enter_field_declaration, VPOS(1)); }
        ( field_specifier_list | field_specifier )      { PCC_INVOKE(exit_field_declaration); }
    | ( attribute_list _ )? ( KW_PUBLIC _ )?            { PCC_INVOKE(enter_field_declaration, NPOS()); }
        field_specifier                                 { PCC_INVOKE(exit_field_declaration); }
    ;

field_specifier_list
    : '{' _ ( field_specifier _ )* '}'

field_specifier
    : <field_identifier> _ ':' _ <type> ( _ '=' _ <expression> )?
                                                        { PCC_INVOKE(on_field_specifier, VPOS(0), VPOS(1), VPOS(2), VPOS(3)); }
    ;

field_identifier
    : identifier
    ;

function_declaration
    : ( attribute_list _ )? ( KW_PUBLIC _ )? ( KW_CONST _ )? 
        < ( KW_FUNCTION _ )? identifier _ ( generic_names _ )?
                                                        { PCC_INVOKE(enter_function_declaration, KW_CONST, KW_FUNCTION, identifier, generic_names); }
        function_signature > ( _ block )?               { PCC_INVOKE(exit_function_declaration, VPOS(1)); }
    ;

function_signature
    : '(' _ ( parameter_list _ )? ')'
        ( _ ':' _ type )?                               { $$=VPOS(0); PCC_INVOKE(on_function_signature, VPOS(0), type); }
    ;

parameter_list
    : parameter_list _ ',' _ parameter_declaration
    | parameter_declaration
    ;

parameter_declaration
    : ( KW_CONST _ )? identifier
        _ ':' _ parameter_type                          { $$=VPOS(0); PCC_INVOKE(on_function_parameter, VPOS(0), KW_CONST, identifier, parameter_type); }
    ;

parameter_type
    : type ( _ '...' )?                                 { $$=VPOS(0); }
    ;

# -------------------- Statements ------------------------------

block
    : '{' _ ( statement_list _ )? '}'
    ;

statement_list
    : statement_list _ statement
    | statement
    ;

statement
    : expression_statement
    ;

expression_statement
    : expression
    ;

# -------------------- Expressions ------------------------------

expression
    : identifier
    | string_literal
    | integer_literal
    | boolean_literal
    | KW_NULL
    | KW_THIS
    | KW_BASE
    ;

identifier
    : basic_identifier                                  { $$=VPOS(0); }
    | '@' KEYWORDS                                      { $$=VPOS(0); }
    ;

basic_identifier
    : LETTER LD*
    ;

string_literal
    : STRING_LITERAL
    ;

integer_literal
    : INTEGER_LITERAL
    ;

boolean_literal
    : KW_TRUE
    | KW_FALSE
    ;

KW_MODULE       : 'module'          !LD
KW_IMPORT       : 'import'          !LD
KW_AS           : 'as'              !LD
KW_IF           : 'if'              !LD
KW_UNSAFE       : 'unsafe'          !LD
KW_PUBLIC       : 'public'          !LD
KW_STRUCT       : 'struct'          !LD
KW_UNION        : 'union'           !LD
KW_CLASS        : 'class'           !LD
KW_INTERFACE    : 'interface'       !LD
KW_ENUM         : 'enum'            !LD
KW_FUNCTION     : 'function'        !LD                 { $$=VPOS(0); }
KW_TYPE         : 'type'            !LD                 { $$=VPOS(0); }
KW_CONST        : 'const'           !LD                 { $$=VPOS(0); }
KW_LET          : 'let'             !LD
KW_VAR          : 'var'             !LD
KW_TRUE         : 'true'            !LD
KW_FALSE        : 'false'           !LD
KW_NULL         : 'null'            !LD
KW_THIS         : 'this'            !LD
KW_BASE         : 'base'            !LD

KEYWORDS        : KW_MODULE | KW_IMPORT | KW_AS

LETTER          : [a-zA-Zα-ωΑ-Ωµ_]
DIGIT           : [0-9]
LD              : LETTER | DIGIT

STRING_LITERAL  : '\"' ( !'\"' . )* '\"'
INTEGER_LITERAL : [0-9]+

_               : (SPACE | EOL | COMMENT)*
SPACE           : [ \u0009\u000B\u000C]
COMMENT         : '//' ( !EOL . )*
                | '/*' ( !'*/' . )* '*/'
EOL             : '\n' | '\r\n' | '\r'
EOF             : !.

%%

#undef PCC_INVOKE
