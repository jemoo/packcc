%prefix "vsharp"

%value "vsp_pos_t"
%auxil "vsparser_t *"

%header {

#include "vsparser.h"

}

%source {

#include <stdio.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef vsharp_context_t pcc_context_t;

int vsp_getchar(vsparser_t* p);
void vsp_debug(vsparser_t *p, int event, const char *rule, int level, size_t pos, const char *buffer, int length);
void vsp_error(vsparser_t *p);
int vsp_whitespace(vsparser_t *p, int action);
void vsp_eat_whitespace(pcc_context_t *ctx);

#ifdef __cplusplus
}
#endif

#define PCC_GETCHAR(auxil)\
        vsp_getchar(auxil)

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length)\
        vsp_debug(auxil, event, rule, (int)level, pos, buffer, (int)length)

#define PCC_ERROR(auxil)\
        vsp_error(auxil)

#define PCC_INVOKE(callback, ...)\
    if (auxil->il.callback)\
        auxil->il.callback(auxil, ##__VA_ARGS__)

#define VPOS(num)\
    vsp_pos(auxil, _##num##s, _##num##e)

#define VRANGE(start, end)\
    vsp_pos(auxil, _##start##s, _##end##e)

#define NPOS()\
    vsp_pos(auxil, 0, 0)

#define EMPTY(num)\
    (_##num##e <= _##num##s)

#ifndef TRUE
#define TRUE    1
#define FALSE   0

    /*{ if (pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, chunk->thunks.len-1); }*/

void vsp_ast_embed(struct pcc_thunk_chunk_tag* chunk, int num, ...);
void vsp_ast_chose(struct pcc_thunk_chunk_tag* chunk, int index);
void vsp_ast_match(struct pcc_thunk_chunk_tag* chunk, const char *name);
void vsp_ast_gen(const struct pcc_thunk_array_tag *thunks);
#define PCC_AST_EMBED(CHUNK, ...)  vsp_ast_embed(CHUNK, __VA_ARGS__)
#define PCC_AST_CHOSE(CHUNK, INDEX) vsp_ast_chose(CHUNK, INDEX)
#define PCC_AST_MATCH(CHUNK, NAME)  vsp_ast_match(CHUNK, NAME)
#define PCC_ACTION(CTX, THUNKS, VALUE)  vsp_ast_gen(THUNKS)
#define PCC_WHITESPACE(CTX, ACTION) {\
    if (vsp_whitespace(CTX->auxil, ACTION)) vsp_eat_whitespace(CTX);\
}

#endif

}

compilation_unit
    : top_level_declaration* EOF
    ;

top_level_declaration
    : module_clause
    | import_declaration
    | type_declaration
    | struct_declaration
    | field_declaration
    | function_declaration
    ;

module_clause
    : attribute_list?
        <KW_MODULE> <module_identifier>               { PCC_INVOKE(on_module_clause, VPOS(1), VPOS(2)); }
    ;

module_identifier
    : IDENTIFIER
    ;

attribute_list
    : attribute_declaration+
    ;

attribute_declaration
    : '[' attribute_spec_list ']'
    ;

attribute_spec_list
    : attribute_spec_list ',' attribute_spec
    | attribute_spec
    ;

attribute_spec
    : KW_IF IDENTIFIER '?'?
    | ( KW_UNSAFE | IDENTIFIER ) ( ':' ( string_literal | IDENTIFIER ) )?
    | interpreted_string_literal
    ;

interpreted_string_literal
    : string_literal
    ;

import_declaration
    : KW_IMPORT module_name                       #{ PCC_INVOKE(enter_import_declaration, VPOS(1), VPOS(2)); }
      ( ( KW_AS IDENTIFIER                      #{ PCC_INVOKE(on_import_alias, VPOS(3), VPOS(4)); }
      | '{' import_symbol_list '}' ) )?             #{ PCC_INVOKE(exit_import_declaration); }
    ;

module_name
    : module_name TOK_DOT IDENTIFIER                  #{ PCC_INVOKE(on_import_module_name, VPOS(1), TRUE); }
    | IDENTIFIER                                        #{ PCC_INVOKE(on_import_module_name, VPOS(0), FALSE); }
    ;

TOK_DOT
    : '.'
    ;

import_symbol_list
    : import_symbol_list _ ',' _ <IDENTIFIER>           { PCC_INVOKE(on_import_symbol, VPOS(1)); }
    | IDENTIFIER                                        { PCC_INVOKE(on_import_symbol, VPOS(0)); }
    ;

type_declaration
    : ( attribute_list _ )? ( KW_PUBLIC _ )?
        <KW_TYPE> _ <type_identifier>                   { PCC_INVOKE(enter_type_declaration, VPOS(1), VPOS(2)); }
        ( _ <generic_names> )?                          { if (!EMPTY(3)) { PCC_INVOKE(on_type_decl_generic_names, VPOS(3)); } }
        _ '=' _ <sum_type_list>                         { PCC_INVOKE(exit_type_declaration, VPOS(4)); }
    ;

sum_type_list
    : sum_type_list _ '|' _ type
    | type
    ;

struct_declaration
    : ( attribute_list _ )? ( KW_PUBLIC _ )?
        < KW_STRUCT | KW_UNION | KW_CLASS | KW_INTERFACE | KW_ENUM >
        _ <IDENTIFIER>                                  { PCC_INVOKE(enter_struct_declaration, VPOS(1), VPOS(2)); }
        ( _ <generic_names> )?                          { if (!EMPTY(3)) { PCC_INVOKE(on_struct_generic_names, VPOS(3)); } }
        ( _ ':' _ super_type_list )?
        _ '{' _ ( struct_member_list _ )? '}'           { PCC_INVOKE(exit_struct_declaration, VPOS(0)); }
    ;

generic_names
    : '<' _ generic_name_list _ '>'                     { $$=VPOS(0); }
    ;

generic_name_list
    : generic_name_list _ ',' _ <generic_name>          { PCC_INVOKE(on_generic_name, VPOS(1)); }
    | generic_name                                      { PCC_INVOKE(on_generic_name, VPOS(0)); }
    ;

generic_name
    : IDENTIFIER
    ;

type
    : simple_type ( _ <'&'> )? ( _ <'?'> )?             { $$=VPOS(0);
                                                          PCC_INVOKE(on_type_reference, VPOS(0), VPOS(1));
                                                          PCC_INVOKE(on_type_nullable, VPOS(0), VPOS(2)); }
    ;

super_type_list
    : super_type_list _ ',' _ super_type                { PCC_INVOKE(on_struct_super_type, TRUE); }
    | super_type                                        { PCC_INVOKE(on_struct_super_type, FALSE); }
    ;

super_type
    : generic_type
    | qualified_type
    | type_identifier
    ;

generic_type
    : ( qualified_type | type_identifier )              { PCC_INVOKE(enter_generic_type); }
        _ '<' _ type_list _ '>'                         { PCC_INVOKE(exit_generic_type); }
    ;

qualified_type
    : <type_identifier> _ '.' _ <type_identifier>       { PCC_INVOKE(on_named_type, VPOS(1), VPOS(2)); }
    ;

type_identifier
    : IDENTIFIER                                        { PCC_INVOKE(on_named_type, NPOS(), VPOS(0)); }
    ;

simple_type
    : pointer_type
    | function_type
    | tuple_type
    | generic_type
    | qualified_type
    | type_identifier
    ;

pointer_type
    : simple_type _ <'*'>                               { PCC_INVOKE(on_type_pointer, VPOS(0), VPOS(1)); }
    ;

function_type
    : KW_FUNCTION                                       { PCC_INVOKE(enter_function_type); }
        _ function_type_signature                       { PCC_INVOKE(exit_function_type, VPOS(0)); }
    ;

function_type_signature
    : '(' _ ( type_list _ )? ')'                        { PCC_INVOKE(on_function_type_parameters); }
        ( _ ':' _ type )?                               { PCC_INVOKE(on_function_type_return_type, type); }
    ;

tuple_type
    :                                                   { PCC_INVOKE(enter_tuple_type); }
        '(' _ type_list _ ')'                           { PCC_INVOKE(exit_tuple_type, VPOS(0)); }
    ;

type_list
    : type_list _ ',' _ type                            { PCC_INVOKE(on_type_list_item, TRUE); }
    | type                                              { PCC_INVOKE(on_type_list_item, FALSE); }
    ;

struct_member_list
    : struct_member_list _ struct_member_declaration
    | struct_member_declaration
    ;

struct_member_declaration
    : field_declaration
    | function_declaration
    ;

field_declaration
    : ( attribute_list _ )? ( KW_PUBLIC _ )?
        < KW_CONST | KW_LET | KW_VAR > _                { PCC_INVOKE(enter_field_declaration, VPOS(1)); }
        ( field_specifier_list | field_specifier )      { PCC_INVOKE(exit_field_declaration); }
    | ( attribute_list _ )? ( KW_PUBLIC _ )?            { PCC_INVOKE(enter_field_declaration, NPOS()); }
        field_specifier                                 { PCC_INVOKE(exit_field_declaration); }
    ;

field_specifier_list
    : '{' _ ( field_specifier _ )* '}'

field_specifier
    : <field_identifier> _ ':' _ <type> ( _ '=' _ <expression> )?
                                                        { PCC_INVOKE(on_field_specifier, VPOS(0), VPOS(1), VPOS(2), VPOS(3)); }
    ;

field_identifier
    : IDENTIFIER
    ;

function_declaration
    : ( attribute_list _ )? ( KW_PUBLIC _ )? ( KW_CONST _ )? 
        < ( KW_FUNCTION _ )? IDENTIFIER _ ( generic_names _ )?
                                                        { PCC_INVOKE(enter_function_declaration, KW_CONST, KW_FUNCTION, IDENTIFIER, generic_names); }
        function_signature > ( _ block )?               { PCC_INVOKE(exit_function_declaration, VPOS(1)); }
    ;

function_signature
    : '(' _ ( parameter_list _ )? ')'
        ( _ ':' _ type )?                               { $$=VPOS(0); PCC_INVOKE(on_function_signature, VPOS(0), type); }
    ;

parameter_list
    : parameter_list _ ',' _ parameter_declaration
    | parameter_declaration
    ;

parameter_declaration
    : ( KW_CONST _ )? IDENTIFIER
        _ ':' _ parameter_type                          { $$=VPOS(0); PCC_INVOKE(on_function_parameter, VPOS(0), KW_CONST, IDENTIFIER, parameter_type); }
    ;

parameter_type
    : type ( _ '...' )?                                 { $$=VPOS(0); }
    ;

# -------------------- Statements ------------------------------

block
    : '{' _ ( statement_list _ )? '}'
    ;

statement_list
    : statement_list _ statement
    | statement
    ;

statement
    : expression_statement
    ;

expression_statement
    : expression
    ;

# -------------------- Expressions ------------------------------

expression
    : IDENTIFIER
    | string_literal
    | integer_literal
    | boolean_literal
    | KW_NULL
    | KW_THIS
    | KW_BASE
    ;

string_literal
    : STRING_LITERAL
    ;

integer_literal
    : INTEGER_LITERAL
    ;

boolean_literal
    : KW_TRUE
    | KW_FALSE
    ;

keywords
    : KW_MODULE | KW_IMPORT | KW_AS
    ;

IDENTIFIER
    : BASIC_IDENTIFIER                                  { $$=VPOS(0); }
    | '@' keywords                                      { $$=VPOS(0); }
    ;

BASIC_IDENTIFIER
    : LETTER LD*
    ;

KW_MODULE       : 'module'          ~LD
KW_IMPORT       : 'import'          ~LD
KW_AS           : 'as'              ~LD
KW_IF           : 'if'              ~LD
KW_UNSAFE       : 'unsafe'          ~LD
KW_PUBLIC       : 'public'          ~LD
KW_STRUCT       : 'struct'          ~LD
KW_UNION        : 'union'           ~LD
KW_CLASS        : 'class'           ~LD
KW_INTERFACE    : 'interface'       ~LD
KW_ENUM         : 'enum'            ~LD
KW_FUNCTION     : 'function'        ~LD                 { $$=VPOS(0); }
KW_TYPE         : 'type'            ~LD                 { $$=VPOS(0); }
KW_CONST        : 'const'           ~LD                 { $$=VPOS(0); }
KW_LET          : 'let'             ~LD
KW_VAR          : 'var'             ~LD
KW_TRUE         : 'true'            ~LD
KW_FALSE        : 'false'           ~LD
KW_NULL         : 'null'            ~LD
KW_THIS         : 'this'            ~LD
KW_BASE         : 'base'            ~LD

LETTER          : [a-zA-Zα-ωΑ-Ωµ_]
DIGIT           : [0-9]
LD              : LETTER | DIGIT

STRING_LITERAL  : '\"' ( ~'\"' . )* '\"'
INTEGER_LITERAL : [0-9]+

_               : (SPACE | EOL | COMMENT)*
SPACE           : [ \u0009\u000B\u000C]
COMMENT         : '//' ( ~EOL . )*
                | '/*' ( ~'*/' . )* '*/'
EOL             : '\n' | '\r\n' | '\r'
EOF             : ~.

%%

#undef PCC_INVOKE

#include <stdarg.h>

void vsp_ast_embed(pcc_thunk_chunk_t* chunk, int num, ...) {
    if (chunk->thunks.len == 0) {
        return;
    }
    pcc_thunk_t* thunk = chunk->thunks.buf[chunk->thunks.len-1];
    if (chunk->ast_info.last_thunk == thunk) {
        return;
    }
    chunk->ast_info.last_thunk = thunk;

    va_list valist;
    va_start(valist, num);
    for (int i = 0; i < num; i++)
    {
        thunk->ast_info.embed[i] = va_arg(valist, int);
    }
    va_end(valist);

    thunk->ast_info.num_embed = num;
}

void vsp_ast_chose(pcc_thunk_chunk_t* chunk, int index) {
    chunk->ast_info.chose = index;
}

void vsp_ast_match(pcc_thunk_chunk_t* chunk, const char *name) {
    chunk->ast_info.name = name;
}

void vsp_ast_push(const char* name);
void vsp_ast_pop(const char* name, bool succeeded);

void vsp_ast_dump(const pcc_thunk_t* thunk) {
    if (thunk->type == PCC_THUNK_NODE) {
        const char *name = thunk->ast_info.chunk_info.name;
        if (name == "_") {
            return;
        }
        vsp_ast_push(name);
        bool term = name[0] >= 'A' && name[0] <= 'Z';
        if (!term) {
            for (size_t i = 0; i < thunk->data.node.thunks->len; i++) {
                vsp_ast_dump(thunk->data.node.thunks->buf[i]);
            }
        }
        vsp_ast_pop(name, true);
    }
}

void vsp_ast_gen(const pcc_thunk_array_t *thunks) {
    if (thunks->len == 1) {
        vsp_ast_dump(thunks->buf[0]);
    }
}

void vsp_eat_whitespace(pcc_context_t *ctx) {

    for (;;) {
        if (pcc_refill_buffer(ctx, 2) == 2) {
            int c0 = (ctx->buffer.buf + ctx->cur)[0];
            int c1 = (ctx->buffer.buf + ctx->cur)[1];
            if (c0 == '\r' && c1 == '\n') {
                ctx->cur += 2;
                continue;
            }
        }

        if (pcc_refill_buffer(ctx, 1) < 1) {
            break;
        }

        int c = ctx->buffer.buf[ctx->cur];
        if (c == 0x000020 ||
            c == 0x000009 ||
            c == 0x00000b ||
            c == 0x00000c ) {
            ctx->cur += 1;
            continue;
        }

        if (c == '\n' || c == '\r') {
            ctx->cur++;
            continue;
        }

        break;
    }


}
