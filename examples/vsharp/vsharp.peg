%prefix "vsharp"

%auxil "vsparser_t *"

%header {

#include "vsparser.h"

}

%source {

#include <stdio.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef vsharp_context_t pcc_context_t;

int vsp_getchar(vsparser_t* p);
void vsp_debug(vsparser_t *p, int event, const char *rule, int level, size_t pos, const char *buffer, int length);
void vsp_error(vsparser_t *p);
void vsp_syntax_error(vsparser_t *p, const char* msg, const char* text, size_t start, size_t stop);
void vsp_whitespace(pcc_context_t *ctx, struct pcc_thunk_chunk_tag *chunk);
void vsp_ast_info(struct pcc_thunk_chunk_tag* chunk, const char *name, int term, size_t start, size_t end);
void vsp_ast_gen(vsparser_t *p, const struct pcc_thunk_array_tag *thunks);

#ifdef __cplusplus
}
#endif

#define PCC_GETCHAR(auxil)\
        vsp_getchar(auxil)

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length)\
        vsp_debug(auxil, event, rule, (int)level, pos, buffer, (int)length)

#define PCC_ERROR(auxil)\
        vsp_error(auxil)

#define PCC_WHITESPACE(CTX, CHUNK)\
        if (CTX->term_mode == 0) vsp_whitespace(CTX, CHUNK)

#define PCC_AST_INFO(CHUNK, NAME, TERM, START, END)\
        vsp_ast_info(CHUNK, NAME, TERM, START, END)

#define PCC_ACTION(CTX, THUNKS, VALUE)\
        vsp_ast_gen(CTX->auxil, THUNKS)

}

compilation_unit
    : top_level_declaration* EOF _*
    ;

inline top_level_declaration
    : module_clause
    | import_directive
    | type_declaration
    | struct_declaration
    | field_declaration
    | function_declaration
    ;

//error
//    : . { vsp_syntax_error(auxil, "unexpected token", $0, $0s, $0e); }
//    ;

module_clause
    : attributes? MODULE module_name
    ;

attributes
    : attribute_section+
    ;

inline attribute_section
    : L_BRACKET attribute_list R_BRACKET
    ;

inline attribute_list
    : attribute ( COMMA attribute )*
    ;

attribute
    : IF IDENTIFIER QUESTION?
    | ( UNSAFE )
    | name=IDENTIFIER ( COLON ( string_literal | IDENTIFIER ) )?
    | interpreted_string_literal
    ;

interpreted_string_literal
    : string_literal
    ;

import_directive
    : IMPORT module_name ( AS alias_name=IDENTIFIER | L_BRACE symbol_names=import_symbols R_BRACE )?
    ;

module_name
    : IDENTIFIER ( DOT IDENTIFIER )* UNEXPECTED_DOT?
    ;

import_symbols
    : IDENTIFIER ( COMMA IDENTIFIER )*
    ;

type_declaration
    : attributes? PUBLIC? TYPE type_identifier generic_names? EQUALS sum_type_list
    ;

sum_type_list
    : type ( BAR type )*
    ;

struct_declaration
    : attributes? PUBLIC? ( STRUCT | UNION | CLASS | INTERFACE | ENUM )
        IDENTIFIER generic_names? ( COLON super_type_list )? L_BRACE struct_member_list? R_BRACE
    ;

inline generic_names
    : L_CHEVRON generic_name_list R_CHEVRON
    ;

inline generic_name_list
    : generic_name ( COMMA generic_name )*
    ;

generic_name
    : IDENTIFIER
    ;

type
    : simple_type AMP? QUESTION?
    ;

inline super_type_list
    : super_type ( COMMA super_type )*
    ;

super_type
    : generic_type
    | qualified_type
    | type_identifier
    ;

generic_type
    : ( qualified_type | type_identifier ) L_CHEVRON type_list R_CHEVRON
    ;

qualified_type
    : type_identifier ( DOT type_identifier )+
    ;

type_identifier
    : IDENTIFIER
    ;

simple_type
    : pointer_type
    | function_type
    | tuple_type
    | generic_type
    | qualified_type
    | type_identifier
    ;

pointer_type
    : simple_type STAR
    ;

function_type
    : FUNC function_type_signature
    ;

function_type_signature
    : L_PAREN type_list? R_PAREN ( COLON type )?
    ;

tuple_type
    : L_PAREN type_list R_PAREN
    ;

type_list
    : type ( COMMA type )*
    ;

inline struct_member_list
    : struct_member_declaration+
    ;

inline struct_member_declaration
    : field_declaration
    | function_declaration
    ;

field_declaration
    : attributes? PUBLIC? ( LET | VAR ) ( field_specifier_list | field_specifier )
    ;

inline field_specifier_list
    : L_BRACE field_specifier* R_BRACE
    ;

field_specifier
    : field_identifier ( COLON type ( EQUALS expression )? | EQUALS expression )
    ;

field_identifier
    : IDENTIFIER
    ;

function_declaration
    : attributes? PUBLIC? CONST? 
        ( FUNC? IDENTIFIER generic_names? function_signature ) block?
    ;

function_signature
    : L_PAREN parameter_list? R_PAREN ( COLON type )?
    ;

inline parameter_list
    : parameter_declaration ( COMMA parameter_declaration )*
    ;

parameter_declaration
    : CONST? IDENTIFIER COLON type DOTDOTDOT?
    ;

// -------------------- Statements ------------------------------

block
    : L_BRACE statement_list? R_BRACE
    ;

inline statement_list
    : statement+
    ;

statement
    : declaration_statement
    | expression_statement
    ;

expression_statement
    : expression
    ;

declaration_statement
    : local_variable_declaration 
    ;

local_variable_declaration 
    : ( LET | VAR ) local_variable_declarators
    ;

inline local_variable_declarators
    : local_variable_declarator ( COMMA local_variable_declarator )*
    ;

local_variable_declarator
    : IDENTIFIER EQUALS local_variable_initializer
    ;

inline local_variable_initializer
    : expression
    ;

// -------------------- Expressions ------------------------------

expression
    : assignment
    | non_assignment_expression
    ;

optimizable non_assignment_expression
    : conditional_expression
    | lambda_expression
    ;

optimizable conditional_expression
    : null_coalescing_expression ( QUESTION true_expression=expression COLON false_expression=expression )?
    ;

optimizable null_coalescing_expression
    : conditional_or_expression ( binary_expression_operator=DBLQUESTION null_coalescing_expression )?
    ;

optimizable conditional_or_expression
    : conditional_or_expression binary_expression_operator=DBLBAR conditional_and_expression
    | conditional_and_expression
    ;

optimizable conditional_and_expression
    : conditional_and_expression binary_expression_operator=DBLAMP inclusive_or_expression
    | inclusive_or_expression
    ;

optimizable inclusive_or_expression
    : inclusive_or_expression binary_expression_operator=BAR exclusive_or_expression
    | exclusive_or_expression
    ;

optimizable exclusive_or_expression
    : exclusive_or_expression binary_expression_operator=CARAT and_expression
    | and_expression
    ;

optimizable and_expression
    : and_expression binary_expression_operator=AMP equality_expression
    | equality_expression
    ;

optimizable equality_expression
    : equality_expression binary_expression_operator=equality_expression_operator relational_expression
    | relational_expression
    ;

optimizable equality_expression_operator
    : COMPAREEQUALS | COMPARENOTEQUALS
    ;

optimizable relational_expression
    : relational_expression
        ( binary_expression_operator=relational_expression_operator shift_expression
        | IS type
        | AS type
        )
    | shift_expression
    ;

optimizable relational_expression_operator
    : L_CHEVRON | R_CHEVRON | LESSEQUALS | GREATEREQUALS
    ;

optimizable shift_expression
    : shift_expression binary_expression_operator=shift_expression_operator additive_expression
    | additive_expression
    ;

optimizable shift_expression_operator
    : L_DBLCHEVRON | R_DBLCHEVRON
    ;

optimizable additive_expression
    : additive_expression binary_expression_operator=additive_expression_operator multiplicative_expression
    | multiplicative_expression
    ;

optimizable additive_expression_operator
    : PLUS | MINUS
    ;

optimizable multiplicative_expression
    : multiplicative_expression binary_expression_operator=multiplicative_expression_operator unary_expression
    | unary_expression
    ;

optimizable multiplicative_expression_operator
    : STAR | DIVIDE | PERCNT
    ;

optimizable unary_expression
    : unary_expression_operator unary_expression
    | primary_expression
    ;

unary_expression_operator
    : INC | DEC | PLUS | MINUS | EXCL | TILDE | STAR | AMP
    ;

optimizable primary_expression
    : primary_no_array_creation_expression
    | array_creation_expression
    ;

optimizable primary_no_array_creation_expression
    : member_access
    //| null_conditional_member_access
    | element_access
    //| null_conditional_element_access
    | post_increment_expression
    | post_decrement_expression
    | invocation_expression
    //| tuple_expression
    | parenthesized_expression
    | literal
    //| interpolated_string_expression
    | this_access
    | base_access
    //| object_creation_expression
    //| delegate_creation_expression
    //| anonymous_object_creation_expression
    | typeof_expression
    | sizeof_expression
    //| checked_expression
    //| unchecked_expression
    //| default_value_expression
    | nameof_expression
    //| anonymous_method_expression
    //| pointer_member_access
    //| pointer_element_access
    //| stackalloc_expression
    | simple_name
    ;

simple_name
    : IDENTIFIER
    ;

parenthesized_expression
    : L_PAREN expression R_PAREN
    ;

member_access
    : primary_expression ( DOT simple_name | QUESTIONDOT simple_name dependent_access* )
    ;

dependent_access
    : DOT simple_name
    | L_BRACKET argument_list R_BRACKET
    | L_PAREN argument_list? R_PAREN
    ;

invocation_expression
    : primary_expression L_PAREN argument_list? R_PAREN
    ;

element_access
    : primary_expression
        ( L_BRACKET argument_list R_BRACKET |
            QUESTIONL_BRACKET argument_list R_BRACKET dependent_access* )
    ;

this_access
    : THIS
    ;

base_access
    : BASE
    ;

post_increment_expression
    : primary_expression INC
    ;

post_decrement_expression
    : primary_expression DEC
    ;

typeof_expression
    : TYPEOF L_PAREN type R_PAREN
    ;

sizeof_expression
    : SIZEOF L_PAREN type R_PAREN
    ;

nameof_expression
    : NAMEOF L_PAREN simple_name R_PAREN
    ;

argument_list
    : argument ( COMMA argument )*
    ;

argument
    : argument_name? argument_value
    ;

inline argument_name
    : IDENTIFIER COLON
    ;

inline argument_value
    : expression
    ;

assignment
    : unary_expression assignment_operator expression
    ;

assignment_operator
    : EQUALS | PLUSEQUALS | MINUSEQUALS | MULTIPLYEQUALS | DIVIDEEQUALS | MODULUSEQUALS
    | ANDEQUALS | OREQUALS | XOREQUALS | SHIFTLEFTEQUALS | SHIFTRIGHTEQUALS
    ;

lambda_expression
    : 'lambda_expression'
    ;

array_creation_expression
    : 'array_creation_expression'
    ;

// -------------------- Literals ------------------------------

inline literal
    : boolean_literal
    | integer_literal
    | real_literal
    | character_literal
    | string_literal
    | null_literal
    ;

boolean_literal
    : TRUE
    | FALSE
    ;

integer_literal
    : INTEGER_LITERAL
    ;

real_literal
    : 'real_literal'
    ;

character_literal
    : CHARACTER_LITERAL
    ;

string_literal
    : STRING_LITERAL
    ;

null_literal
    : NULL
    ;

// -------------------- Keywords ------------------------------

keywords
    : MODULE | IMPORT | AS | CLASS
    ;

// -------------------- Terminals ------------------------------

IDENTIFIER
    : ~keywords BASIC_IDENTIFIER
    | '@' keywords
    ;

BASIC_IDENTIFIER
    : LETTER ( LETTER | DIGIT )*
    ;

MODULE          : 'module'          ~LD
IMPORT          : 'import'          ~LD
AS              : 'as'              ~LD
IS              : 'is'              ~LD
IF              : 'if'              ~LD
UNSAFE          : 'unsafe'          ~LD
PUBLIC          : 'public'          ~LD
STRUCT          : 'struct'          ~LD
UNION           : 'union'           ~LD
CLASS           : 'class'           ~LD
INTERFACE       : 'interface'       ~LD
ENUM            : 'enum'            ~LD
FUNC            : 'func'            ~LD
TYPE            : 'type'            ~LD
CONST           : 'const'           ~LD
LET             : 'let'             ~LD
VAR             : 'var'             ~LD
TRUE            : 'true'            ~LD
FALSE           : 'false'           ~LD
NULL            : 'null'            ~LD
THIS            : 'this'            ~LD
BASE            : 'base'            ~LD
TYPEOF          : 'typeof'          ~LD
SIZEOF          : 'sizeof'          ~LD
NAMEOF          : 'nameof'          ~LD

LETTER          : [a-zA-Zα-ωΑ-Ωµ_]
DIGIT           : [0-9]
LD              : LETTER | DIGIT

STRING_LITERAL      : '\"' ( ~'\"' . )* '\"'
CHARACTER_LITERAL   : '\'' ( ~'\'' . )* '\''
INTEGER_LITERAL     : [0-9]+

L_BRACE         : '{'
R_BRACE         : '}'
L_PAREN         : '('
R_PAREN         : ')'
L_BRACKET       : '['
R_BRACKET       : ']'
AMP             : '&'
QUESTION        : '?'
DBLQUESTION     : '??'
QUESTIONDOT     : '?.'
QUESTIONL_BRACKET   : '?['
STAR            : '*'
DOT             : '.'
DOTDOTDOT       : '...'
COMMA           : ','
COLON           : ':'
CARAT           : '^'
EQUALS          : '='
BAR             : '|'
DBLBAR          : '||'
DBLAMP          : '&&'
PLUS            : '+'
MINUS           : '-'
INC             : '++'
DEC             : '--'
EXCL            : '!'
TILDE           : '~'
DIVIDE          : '/'
PERCNT          : '%'
L_DBLCHEVRON    : '<<'
R_DBLCHEVRON    : '>>'
L_CHEVRON       : '<'
R_CHEVRON       : '>'
LESSEQUALS      : '<='
GREATEREQUALS   : '>='
COMPAREEQUALS   : '=='
COMPARENOTEQUALS: '!='
PLUSEQUALS      : '+='
MINUSEQUALS     : '-='
MULTIPLYEQUALS  : '*='
DIVIDEEQUALS    : '/='
MODULUSEQUALS   : '%='
ANDEQUALS       : '&='
OREQUALS        : '|='
XOREQUALS       : '^='
SHIFTLEFTEQUALS : '<<='
SHIFTRIGHTEQUALS    : '>>='

_               : SPACE | EOL | COMMENT
SPACE           : [ \u0009\u000B\u000C]
COMMENT         : '//' ( ~EOL . )*
                | '/*' ( ~'*/' . )* '*/'
EOL             : '\n' | '\r\n' | '\r'
EOF             : ~.

UNEXPECTED_DOT
    : '.' { vsp_syntax_error(auxil, "unexpected '.'", $0, $0s, $0e); }
    ;

%%

void vsp_ast_info(struct pcc_thunk_chunk_tag* chunk, const char *name, int term, size_t start, size_t end) {
    if (chunk->thunks.len == 0) {
        //printf("xxxxxxxx %s\n", name);
        return;
    }
    pcc_thunk_t* thunk = chunk->thunks.buf[chunk->thunks.len-1];
/*
    if (chunk->ast_info.last_thunk == thunk) {
        //printf("-x-x-x-x %s\n", name);
        return;
    }
    chunk->ast_info.last_thunk = thunk;
*/
    //printf("-------- %s\n", name);

    thunk->ast_info.name = name;
    thunk->ast_info.term = term;
    thunk->ast_info.start = start;
    thunk->ast_info.end = end;
}

void vsp_ast_push(vsparser_t *p, const char* name, int term, size_t start, size_t end);
void vsp_ast_pop(vsparser_t *p, const char* name, bool succeeded);

void vsp_ast_dump(vsparser_t *p, const pcc_thunk_t* thunk) {
    const char *name = thunk->ast_info.name;
    if (!name) {
        return;
    }
    if (thunk->type == PCC_THUNK_NODE) {
        vsp_ast_push(p, name, thunk->ast_info.term, thunk->ast_info.start, thunk->ast_info.end);
        for (size_t i = 0; i < thunk->data.node.thunks->len; i++) {
            vsp_ast_dump(p, thunk->data.node.thunks->buf[i]);
        }
        vsp_ast_pop(p, name, true);
    }
}

void vsp_ast_gen(vsparser_t *p, const pcc_thunk_array_t *thunks) {
    if (thunks->len == 1) {
        thunks->buf[0]->ast_info.name = "root";
        vsp_ast_dump(p, thunks->buf[0]);
    }
}

void vsp_whitespace(pcc_context_t *ctx, pcc_thunk_chunk_t *chunk) {
    if (pcc_apply_rule(ctx, pcc_evaluate_rule__, &chunk->thunks, NULL)) {
        pcc_thunk_array__revert(ctx->auxil, &chunk->thunks, chunk->thunks.len-1);
    }
}
